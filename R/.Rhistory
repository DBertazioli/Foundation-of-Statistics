geom_histogram(aes(y =..density..),
bins= 25,
fill = "grey",
color ="black") +
geom_vline(xintercept = mean(data$LogPrice), color = "dark red") +
geom_vline(xintercept = mean(data$LogPrice) + sd(data$LogPrice), color = "dark red", lty = 2) +
geom_vline(xintercept = mean(data$LogPrice) - sd(data$LogPrice), color = "dark red", lty = 2) +
labs(x = "Price", y ="Density") +
ggtitle("Price Distribution (mean +/- sd)") +
geom_density()
```{r}
ggplot(data, aes(x = Price, fill = TypeName)) +
geom_density(size = 0.6, alpha = .3) +
labs(x = "Price", y ="Density", fill = "TypeName") +
ggtitle("Price Density Distribution For TypeName")
ggplot(data, aes(x = log(Price), fill = TypeName)) +
geom_density(size = 0.6, alpha = .3) +
labs(x = "log(Price)", y ="Density", fill = "TypeName") +
ggtitle("log(Price) Density Distribution For TypeName")
ggplot(data, aes(x = Price, fill = SolidStateDisk)) +
geom_density(size = 0.6, alpha = .3) +
labs(x = "Price", y ="Density", fill = "SolidStateDisk") +
ggtitle("Price Density Distribution For SolidStateDisk")
ggplot(data, aes(x = log(Price), fill = SolidStateDisk)) +
geom_density(size = 0.6, alpha = .3) +
labs(x = "log(Price)", y ="Density", fill = "SolidStateDisk") +
ggtitle("log(Price) Density Distribution For SolidStateDisk")
ggplot(data,aes(x = Price)) +
geom_histogram(aes(y =..density..),
bins= 25,
fill = "grey",
color ="black") +
geom_vline(xintercept = quantile(data$Price, 0.25), color = "dark red") +
geom_vline(xintercept = quantile(data$Price, 0.5), color = "dark red", lty = 2) +
geom_vline(xintercept = quantile(data$Price, 0.75), color = "dark red", lty = 2) +
labs(x = "Price", y ="Density") +
ggtitle("Price Distribution (mean +/- sd)") +
geom_density()
ggplot(data,aes(x = Price)) +
geom_histogram(aes(y =..density..),
bins= 25,
fill = "grey",
color ="black") +
geom_vline(xintercept = quantile(data$Price, 0.25), color = "dark red") +
geom_vline(xintercept = quantile(data$Price, 0.5), color = "dark red", lty = 2) +
geom_vline(xintercept = quantile(data$Price, 0.75), color = "dark red", lty = 2) +
labs(x = "Price", y ="Density") +
ggtitle("Price Distribution (mean +/- sd)") +
geom_density()
ggplot(data,aes(x = Price)) +
geom_histogram(aes(y =..density..),
bins= 25,
fill = "grey",
color ="black") +
geom_vline(xintercept = quantile(data$Price, 0.25), color = "dark red") +
geom_vline(xintercept = quantile(data$Price, 0.5), color = "dark red", lty = 2) +
geom_vline(xintercept = quantile(data$Price, 0.75), color = "dark red", lty = 2) +
labs(x = "Price", y ="Density") +
ggtitle("Price Distribution (mean +/- sd)") +
geom_density()
ggplot(data,aes(x = Price)) +
geom_histogram(aes(y =..density..),
bins= 25,
fill = "grey",
color ="black") +
geom_vline(xintercept = quantile(data$Price, 0.25), color = "dark red",lty = 2) +
geom_vline(xintercept = quantile(data$Price, 0.5), color = "dark red", ) +
geom_vline(xintercept = quantile(data$Price, 0.75), color = "dark red", lty = 2) +
labs(x = "Price", y ="Density") +
ggtitle("Price Distribution (mean +/- sd)") +
geom_density()
ggplot(data,aes(x = log(Price))) +
geom_histogram(aes(y =..density..),
bins= 25,
fill = "grey",
color ="black") +
geom_vline(xintercept = quantile(data$LogPrice, 0.25), color = "dark red",lty = 2) +
geom_vline(xintercept = quantile(data$LogPrice, 0.5), color = "dark red", ) +
geom_vline(xintercept = quantile(data$LogPrice, 0.75), color = "dark red", lty = 2) +
labs(x = "log(Price)", y ="Density") +
ggtitle("log(Price) Distribution (quartiles)") +
geom_density()
library(psych)
describe(data$Price)
boxplot(data$Price)
qqnorm(data$Price);qqline(data$Price)
shapiro.test(data$Price)
boxplot(data$LogPrice)
qqnorm(data$LogPrice);qqline(data$LogPrice)
shapiro.test(data$LogPrice)
# Correzione NORMALITA'
library(nortest)
ad.test(data$LogPrice)
ad.test(data$Price)
shapiro.test(data$Price)
ad.test(data$Price)
wilcox.test(data$Price, conf.int = TRUE, mu = )
#wilcox.test(data$Price, conf.int = TRUE, mu = ) #worth it?
#Var !=1
varTest(sample(data$Price), sigma.squared = (sd(data$Price)*sd(data$Price)))
#wilcox.test(data$Price, conf.int = TRUE, mu = ) #worth it?
library(EnvStats)
#wilcox.test(data$Price, conf.int = TRUE, mu = ) #worth it?
if(!require(Envstats)) install.packages("EnvStats")
#wilcox.test(data$Price, conf.int = TRUE, mu = ) #worth it?
if(!require(Envstats)) install.packages("EnvStats")
library(EnvStats)
varTest(sample(data$Price), sigma.squared = (sd(data$Price)*sd(data$Price)))
#wilcox.test(data$Price, conf.int = TRUE, mu = ) #worth it?
if(!require(Envstats)) install.packages("EnvStats")
boxplot(data$Price~data$Company,
main="Boxplot Prezzo per compagnia",
col= rainbow(6),
horizontal = F)
drop1(lmA, test = 'F')
lmA = lm(Price ~ SolidStateDisk, data=data)
summary(lmA)
drop1(lmA, test = 'F')
anova(lmA)
drop1(lmB, test = 'F')
lmB = lm(Price ~ Company, data=data)
summary(lmB)
drop1(lmB, test = 'F')
anova(lmB)
lmC = lm(Price ~ TypeName, data=data)
summary(lmC)
drop1(lmC, test = 'F')
anova(lmC)
ls_value = lsmeans(lmA,
pairwise ~ value,
adjust = 'tukey')
library(lsmeans)
ls_value = lsmeans(lmA,pairwise ~ SolidStateDisk,
adjust = 'tukey')
ls_value$contrasts
ls_value$lsmeans
plot(ls_value$lsmeans, alpha = .05)
ls_SolidStateDisk = lsmeans(lmA,pairwise ~ SolidStateDisk,adjust = 'tukey')
ls_SolidStateDisk$contrasts
ls_SolidStateDisk$lsmeans
plot(ls_SolidStateDisk$lsmeans, alpha = .05)
ls_Company = lsmeans(lmA,pairwise ~ Company,adjust = 'tukey')
ls_Company$contrasts
ls_Company = lsmeans(lmB,pairwise ~ Company,adjust = 'tukey')
ls_Company$contrasts
ls_Company$lsmeans
plot(ls_Company$lsmeans, alpha = .05)
ls_Company$contrasts
ls_TypeName = lsmeans(lmC,pairwise ~ TypeName,adjust = 'tukey')
ls_TypeName$contrasts
ls_TypeName$lsmeans
plot(ls_TypeName$lsmeans, alpha = .05)
plot(ls_Company$lsmeans, alpha = .05)
summary(lmA)
lmB = lm(Price ~ Company, data=data)
summary(lmB)
summary(lmC)
library(coefplot)
library(forestmodel)
#library(forestmodel)
coefplot(lmC, intercept = FALSE)
par(mfrow = c(2,2))
plot(lm_value)
plot(lmC)
#(not) normal distribution of residuals
par(mfrow=c(1,2))
boxplot(lmC$residuals)
qqnorm(lmC$residuals);qqline(lmC$residuals)
boxplot(lmC$residuals)
ad.test(lmC$residuals)
shapiro.test(lmC$residuals)
#let's try again with the log correction
lmC = lm(log(Price) ~ TypeName, data=data)
summary(lmC_log)
#let's try again with the log correction
lmC_log = lm(log(Price) ~ TypeName, data=data)
summary(lmC_log)
drop1(lmC_log, test = 'F')
anova(lmC_log)
#let's try again with the log correction
lmC_log = lm(log(Price) ~ TypeName, data=data)
summary(lmC_log)#R^2 increases
drop1(lmC_log, test = 'F')
anova(lmC_log)
ls_TypeName_log = lsmeans(lmC_log,pairwise ~ TypeName,adjust = 'tukey')
ls_TypeName_log$contrasts
ls_TypeName_log$lsmeans
plot(ls_TypeName_log$lsmeans, alpha = .05)
plot(ls_TypeName_log$lsmeans, alpha = .05)
coefplot(lmC_log, intercept = FALSE)
par(mfrow = c(2,2))
plot(lmC_log)
#(not) normal distribution of residuals
par(mfrow=c(1,2))
boxplot(lmC_log$residuals)
qqnorm(lmC_log$residuals);qqline(lmC_log$residuals)
ad.test(lmC_log$residuals)
shapiro.test(lmC_log$residuals)
shapiro.test(lmC_log$residuals) #borderline now!
lm_full = lm(Price ~ ., data = data)
summary(lm_full))
summary(lm_full)
anova(lm_full, test="F")
drop1(lm_full, test="F")
coefplot(lm_full, intercept=FALSE)
par(mfrow=c(2,2))
plot(lm_full)
par(mfrow=c(1,1))
par(mfrow=c(1,2))
boxplot(lm_full$residuals)
qqnorm(lm_full$residuals);qqline(lm_full$residuals)
#tests
ad.test(lm_full$residuals)
shapiro.test(lm_full$residuals)
library(MASS)
boxcoxreg1<-boxcox(lm_full)
which.max(boxcoxreg1$y)
lambda=boxcoxreg1$x[which.max(boxcoxreg1$y)]
lambda
lm_full_t = lm(log(Price) ~ ., data = data)
par(mfrow=c(2,2))
plot(lm_full_t)
ad.test(lm_full_t$residuals)
shapiro.test(lm_full_t$residuals)
ad.test(lm_full_t$residuals) #not really
shapiro.test(lm_full_t$residuals)  #not really
influencePlot(lm_full,main="Influence Plot", sub="Circle size is proportial to Cook's Distance" )
library(car)
influencePlot(lm_full,main="Influence Plot", sub="Circle size is proportial to Cook's Distance" )
#Cook's Distance
cooksd <- cooks.distance(lm_full_t)
cooksda=data.frame(cooksd)
summary(cooksd)
# identify D values > 4/(n-k-1)
# Cook's D plot
cutoff <- 4/((nrow(data)-length(lm_full_t$coefficients)-2))
plot(lm_full_t, which=4, cook.levels=cutoff)
plot(cooksd, pch="*", cex=1, main="Influential Obs by Cooks distance") # plot cook's distance
abline(h = cutoff, col="red") # add cutoff line
plot(cooksd, pch="*", cex=1, main="Influential Obs by Cooks distance") # plot cook's distance
abline(h = cutoff, col="red") # add cutoff line
text(x=1:length(cooksd)+1, y=cooksd, labels=ifelse(cooksd>4*mean(cooksd, na.rm=T),names(cooksd),""),
col="red")#add labels
#extract influencial obs
influential <- as.numeric(names(cooksd)[(cooksd > cutoff)]) # influential row numbers
influ=data.frame(data[cooksd > cutoff, ])
filtered_data <- data[ !(row.names(data) %in% c(influential)), ]
#Outlier rimossi
lm_full_t_no_OUTliers = lm(log(market_value) ~ ., data = filtered_data)
#Outlier rimossi
lm_full_t_no_OUTliers = lm(log(Price) ~ ., data = filtered_data)
par(mfrow=c(2,2))
plot(lm_full_t_no_OUTliers)
ncvTest(lm_full_t_no_OUTliers)
summary(lm_full_t_no_OUTliers)
null = lm(log(market_value) ~ 1, data = filtered_data)
null = lm(log(Price) ~ 1, data = filtered_data)
full = lm(log(Price) ~ ., data = filtered_data)
full = lm(log(Price) ~ ., data = filtered_data)
lm_fit = stepAIC(null, scope = list(upper = full), direction = "both", trace = FALSE)
drop1(lm_fit, test = 'F')
library(nortest)
VarTest(sample(data$Price), sigma.squared = (sd(data$Price)*sd(data$Price)))
#wilcox.test(data$Price, conf.int = TRUE, mu = ) #worth it?
#if(!require(Envstats)) install.packages("EnvStats")
library(EnvStats)
VarTest(sample(data$Price), sigma.squared = (sd(data$Price)*sd(data$Price)))
#wilcox.test(data$Price, conf.int = TRUE, mu = ) #worth it?
#if(!require(Envstats)) install.packages("EnvStats")
library(EnvStats)
library(htest)
library(h.test)
varTest(sample(data$Price), sigma.squared = (sd(data$Price)*sd(data$Price)))
# Con interazione
lmC = lm(Price ~ Company*TypeName  , data=data)
data$LogPrice=NULL
lm_full = lm(Price ~ ., data = data)
summary(lm_full)
str(data)
data$Product=NULL
str(data)
data$X=NULL
str(data)
knitr::opts_chunk$set(echo = TRUE)
data <- read.csv("../data/Laptop2.csv")
str(data)
head(data)
data <- read.csv("../data/Laptop2.csv")
str(data)
head(data)
```{r}
summary(data)
summary(data)
```{r}
nums <- sapply(data, is.numeric)
var_numeric <- data[,nums]
head(var_numeric)
nums <- sapply(data, is.numeric)
var_numeric <- data[,nums]
head(var_numeric)
```{r}
data$Weight<-as.numeric(data$Weight)
data$Ram<-as.numeric(data$Ram)
data$Weight<-as.numeric(data$Weight)
data$Ram<-as.numeric(data$Ram)
```{r}
sapply(data, function(x)(sum(is.na(x))))
# Non ci sono missing data!
```{r}
plot(data$Company,data$Price)
plot(data$Company,data$Price)
```{r}
class(data$Ram)
plot(density(data$Frequenza))
#hist(data$Price, breaks=25, probability=TRUE)
#lines(density(data$Price))
```{r}
library(ggplot2)
ggplot(data,aes(x = Price)) +
geom_histogram(aes(y =..density..),
bins= 25,
fill = "grey",
color ="black") +
geom_vline(xintercept = quantile(data$Price, 0.50), color = "dark red", lty = 2) +
geom_vline(xintercept = mean(data$Price), color = "dark blue", lty = 2) +
labs(x = "Price", y ="Density") +
ggtitle("Price Distribution with mean and median") +
geom_density()
Quite skewed to the right, mean > media
We could try to apply a correction like Log(Y)
```{r}
data$LogPrice=log(data$Price)
ggplot(data,aes(x = log(Price))) +
geom_histogram(aes(y =..density..),
bins= 25,
fill = "grey",
color ="black") +
geom_vline(xintercept = quantile(data$LogPrice, 0.50), color = "dark red", lty = 2) +
geom_vline(xintercept = mean(data$LogPrice), color = "dark blue", lty = 2) +
labs(x = "log(Price)", y ="Density") +
ggtitle("log(Price) Distribution with mean and median")+  geom_density()
data$LogPrice=log(data$Price)
ggplot(data,aes(x = log(Price))) +
geom_histogram(aes(y =..density..),
bins= 25,
fill = "grey",
color ="black") +
geom_vline(xintercept = quantile(data$LogPrice, 0.50), color = "dark red", lty = 2) +
geom_vline(xintercept = mean(data$LogPrice), color = "dark blue", lty = 2) +
labs(x = "log(Price)", y ="Density") +
ggtitle("log(Price) Distribution with mean and median")+  geom_density()
Now the distribution is looking a bit better (as regards normality)
```{r}
ggplot(data,aes(x = Price)) +
geom_histogram(aes(y =..density..),
bins= 25,
fill = "grey",
color ="black") +
geom_vline(xintercept = mean(data$Price), color = "dark red") +
geom_vline(xintercept = mean(data$Price) + sd(data$Price), color = "dark red", lty = 2) +
geom_vline(xintercept = mean(data$Price) - sd(data$Price), color = "dark red", lty = 2) +
labs(x = "Price", y ="Density") +
ggtitle("Price Distribution (mean +/- sd)") +
geom_density()
```{r}
ggplot(data,aes(x = log(Price))) +
geom_histogram(aes(y =..density..),
bins= 25,
fill = "grey",
color ="black") +
geom_vline(xintercept = mean(data$LogPrice), color = "dark red") +
geom_vline(xintercept = mean(data$LogPrice) + sd(data$LogPrice), color = "dark red", lty = 2) +
geom_vline(xintercept = mean(data$LogPrice) - sd(data$LogPrice), color = "dark red", lty = 2) +
labs(x = "log(Price)", y ="Density") +
ggtitle("log(Price) Distribution (mean +/- sd)") +
geom_density()
```{r}
ggplot(data,aes(x = Price)) +
geom_histogram(aes(y =..density..),
bins= 25,
fill = "grey",
color ="black") +
geom_vline(xintercept = quantile(data$Price, 0.25), color = "dark red",lty = 2) +
geom_vline(xintercept = quantile(data$Price, 0.5), color = "dark red", ) +
geom_vline(xintercept = quantile(data$Price, 0.75), color = "dark red", lty = 2) +
labs(x = "Price", y ="Density") +
ggtitle("Price Distribution (quartiles)") +
geom_density()
ggplot(data,aes(x = log(Price))) +
geom_histogram(aes(y =..density..),
bins= 25,
fill = "grey",
color ="black") +
geom_vline(xintercept = quantile(data$LogPrice, 0.25), color = "dark red",lty = 2) +
geom_vline(xintercept = quantile(data$LogPrice, 0.5), color = "dark red", ) +
geom_vline(xintercept = quantile(data$LogPrice, 0.75), color = "dark red", lty = 2) +
labs(x = "log(Price)", y ="Density") +
ggtitle("log(Price) Distribution (quartiles)") +
geom_density()
ggplot(data,aes(x = log(Price))) +
geom_histogram(aes(y =..density..),
bins= 25,
fill = "grey",
color ="black") +
geom_vline(xintercept = quantile(data$LogPrice, 0.25), color = "dark red",lty = 2) +
geom_vline(xintercept = quantile(data$LogPrice, 0.5), color = "dark red", ) +
geom_vline(xintercept = quantile(data$LogPrice, 0.75), color = "dark red", lty = 2) +
labs(x = "log(Price)", y ="Density") +
ggtitle("log(Price) Distribution (quartiles)") +
geom_density()
Descrittive variabile dipendente price
```{r}
ggplot(data, aes(x = Price, fill = TypeName)) +
geom_density(size = 0.6, alpha = .3) +
labs(x = "Price", y ="Density", fill = "TypeName") +
ggtitle("Price Density Distribution For TypeName")
ggplot(data, aes(x = log(Price), fill = TypeName)) +
geom_density(size = 0.6, alpha = .3) +
labs(x = "log(Price)", y ="Density", fill = "TypeName") +
ggtitle("log(Price) Density Distribution For TypeName")
ggplot(data, aes(x = Price, fill = SolidStateDisk)) +
geom_density(size = 0.6, alpha = .3) +
labs(x = "Price", y ="Density", fill = "SolidStateDisk") +
ggtitle("Price Density Distribution For SolidStateDisk")
ggplot(data, aes(x = log(Price), fill = SolidStateDisk)) +
geom_density(size = 0.6, alpha = .3) +
labs(x = "log(Price)", y ="Density", fill = "SolidStateDisk") +
ggtitle("log(Price) Density Distribution For SolidStateDisk")
lmA = lm(Price ~ SolidStateDisk, data=data)
data <- read.csv("../data/Laptop2.csv")
str(data)
lmA = lm(Price ~ SolidStateDisk, data=data)
summary(lmA)
str(data)
lm_gpu_test=lm(Price~Gpu)
lm_gpu_test=lm(Price~Gpu, data = data)
summary(lm_gpu_test)
lm_gpu_test=lm(Price~GpuCompany, data = data)
summary(lm_gpu_test)
drop1(lm_gpu_test, test = 'F')
anova(lm_gpu_test)
lm_gpu_test=lm(Price~GpuCompany+ dedicated_gpu, data = data)
str(data)
lm_gpu_test=lm(Price~GpuCompany+ dedicated_GPU, data = data)
summary(lm_gpu_test)
data$dedicated_GPU
summary(data$dedicated_GPU)
lm_gpu_test=lm(Price~GpuCompany+ dedicated_GPU, data = data)
summary(lm_gpu_test)
drop1(lm_gpu_test, test = 'F')
lm_gpu_test=lm(Price~GpuCompany+ SolidStateDisk, data = data)
summary(lm_gpu_test)
lm_gpu_test=lm(Price~GpuCompany, data = data)
summary(lm_gpu_test)
drop1(lm_gpu_test, test = 'F')
anova(lm_gpu_test)
summary(data$dedicated_GPU)
lm_gpu_test=lm(Price~dedicated_GPU, data = data)
summary(lm_gpu_test)
drop1(lm_gpu_test, test = 'F')
anova(lm_gpu_test)
ggplot(data, aes(x = Price, fill = SolidStateDisk)) +
geom_density(size = 0.6, alpha = .3) +
labs(x = "Price", y ="Density", fill = "SolidStateDisk") +
ggtitle("Price Density Distribution For SolidStateDisk")
ggplot(data, aes(x = log(Price), fill = SolidStateDisk)) +
geom_density(size = 0.6, alpha = .3) +
labs(x = "log(Price)", y ="Density", fill = "SolidStateDisk") +
ggtitle("log(Price) Density Distribution For SolidStateDisk")
# One sample
ref <- mean(data$Price)
Apple<-data$Price[data$Company=="Apple"]
t.test(Apple,mu=ref,alternative = "greater")
# Wilcoxon Signed Rank Test
wilcox.test(Apple, mu=ref, conf.int = TRUE)
# One sample
ref <- mean(data$Price)
#FIXME: worth it Fisher test?
#like
fish.a = fisher.test(b.table)
data <- read.csv("../data/Laptop2.csv")
lmB = lm(Price ~ Company, data=data)
summary(lmB)
lmB_agg = lm(Price ~ Aggregated_Company, data=data)
summary(lmB_agg)
summary(lmB)
ls_Company = lsmeans(lmB,pairwise ~ Company,adjust = 'tukey')
library(lsmeans)
library(lsmeans)
ls_Company = lsmeans(lmB,pairwise ~ Company,adjust = 'tukey')
#ls_Company$contrasts #too long to be printed
ls_Company$lsmeans
#ls_Company$contrasts #FIXME: too long to be printed
#ls_Company$lsmeans #mFIXME: aybe only the plot is enough?
plot(ls_Company$lsmeans, alpha = .05)
ls_Company_agg = lsmeans(lmB_agg,pairwise ~ Company,adjust = 'tukey')
ls_Company_agg = lsmeans(lmB_agg,pairwise ~ Aggregated_Company,adjust = 'tukey')
#ls_Company_agg$contrasts #FIXME: too long to be printed
#ls_Company_agg$lsmeans #mFIXME: aybe only the plot is enough?
plot(ls_Company$lsmeans, alpha = .05)
#ls_Company_agg$contrasts #FIXME: too long to be printed
#ls_Company_agg$lsmeans #mFIXME: aybe only the plot is enough?
plot(ls_Company_agg$lsmeans, alpha = .05)
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE, fig.width=10, fig.height=10)
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE, fig.align="center")
#to justify log correction
boxcoxreg1<-boxcox(lm_full, plotit=True)
library(MASS)
#to justify log correction
boxcoxreg1<-boxcox(lm_full, plotit=True)
#to justify log correction
boxcoxreg1<-boxcox(lm_full, plotit=T)
